# -*- coding: utf-8 -*-
"""
Author: Jack Bellamy
Date: 07/04/23
Task: Smooth Step Functions
"""

#Modules Used
import matplotlib.pyplot as plt
import math
import time
import statistics

#A comparison of each smooth step function on the plot (-0.5  < x < 1.5)
def functionComparison():
    
    #List of points generated by each smooth step function
    smoothStepPoints = [] #List for smoothStep(x) 
    smootherStepPoints = [] #List for smootherStep(x)
    sigmoidPoints = []
    inverseSmooth = [] #List for invSmoothStep(x)
    xPoints = [] #List for x values to be used in plot
    
    for x in range(-500,1500):
        x = x / 1000 #Rescale x to be (0 < x < 1)
        
        smoothStepPoints.append(smoothStep(x))
        smootherStepPoints.append(smootherStep(x))
        sigmoidPoints.append(sigmoid(x))
        inverseSmooth.append(invSmoothStep(x))
        xPoints.append(x)
        
    #Graphing of results
    plt.plot(xPoints,smoothStepPoints,c='blue',label='Smooth Step') #Graph for smoothStep(x) 
    plt.plot(xPoints,smootherStepPoints,c='green',label='Smoother Step') #Graph for smootherStep(x)
    plt.plot(xPoints,sigmoidPoints,c='purple',label='Sigmoid Func') #Graph for smootherStep(x)
    # plt.plot(xPoints,inverseSmooth,c='red',label='Inverse Smooth Step') #Graph for smootherStep(x)
    plt.title('Comparison of Smooth Step Functions')
    plt.grid()
    plt.legend()
    plt.show()
    
    
#Speed/Time Comparison
def timeComparison():
    
    smoothTime = []
    smootherTime = []
    sigmoidTime = []
    
    interations = 25
    x = [x/100000 for x in range(0,100001)]
    xLen = len(x)
    
    for j in range(0,interations):
        
        smoothTest = time.time()
        for i in range(0,xLen):
            smoothStep(x[i])
        smoothTest = time.time() - smoothTest
        smoothTime.append(smoothTest)
        #
        smootherTest = time.time()
        for i in range(0,xLen):
            smootherStep(x[i])
        smootherTest = time.time() - smootherTest
        smootherTime.append(smootherTest)
        #
        sigmoidTest = time.time()
        for i in range(0,xLen):
            sigmoid(x[i])
        sigmoidTest = time.time() - sigmoidTest
        sigmoidTime.append(sigmoidTest)
    
    #
    times = [statistics.mean(smoothTime),statistics.mean(smootherTime),statistics.mean(sigmoidTime)]
    names = ['Smooth Step','Smoother Step','Sigmoid Func']
    
    #Graphing of times
    plt.bar(names,times)
    # plt.xticks(rotation=30)
    plt.title('Times of Each Function')
    plt.ylabel('Run time')
    plt.xlabel('Method of Interpolation')
    plt.grid()
    plt.show()

###############################################################################
########################   Interpolation Functions   ##########################
###############################################################################
        
#Classic smooth step function
def smoothStep(x):
    
    if x <= 0:
        return 0
    elif x >= 1:
        return 1
    else:
        smooth = (3 * math.pow(x,2)) - (2 * math.pow(x,3)) #Smoothing function
        return smooth
    
    
#Ken Perlin smoother step function
def smootherStep(x):
    
    if x <= 0:
        return 0
    elif x >= 1:
        return 1
    else:
        smooth = (6 * math.pow(x,5)) - (15 * math.pow(x,4)) + + (10 * math.pow(x,3)) #Smoothing function
        return smooth
    
    
#Sigmoid Function
def sigmoid(x):
    
    s = 5 #How steep the step will be
    fx = 1 / (1 + math.exp(-s * (x-0.5))) #Sigmoid function translated to have midpoint at (0.5,0.5)
    return fx


#Inverse of classic smooth step function
def invSmoothStep(x):
    
    if x <= 0:
        return 0
    elif x >= 1:
        return 1
    else:
        invSmooth = 0.5 - math.sin(math.asin(1 - (2*x)) / 3) #Inverse smoothing function
        return invSmooth
